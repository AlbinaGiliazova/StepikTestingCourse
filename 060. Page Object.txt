Что такое Page Object Model?
Page Object Model или кратко Page Object — это паттерн программирования, который очень популярен в автоматизации тестирования и является одним из стандартов при автоматизации тестирования веб-продуктов. Это также один из удобных способов структурировать свой код таким образом, чтобы его было удобно поддерживать, менять и работать с ним.

Основная идея состоит в том, что каждую страницу веб-приложения можно описать в виде объекта класса. Способы взаимодействия пользователя со страницей можно описать с помощью методов класса. В идеале тест, который будет использовать Page Object, должен описывать бизнес-логику тестового сценария и скрывать Selenium-методы взаимодействия с браузером и страницей. При изменениях в верстке страницы не придется исправлять тесты, связанные с этой страницей. Вместо этого нужно будет поправить только класс, описывающий страницу.

То есть здесь применяются те же принципы, что и в разработке: мы хотим повысить читаемость кода и вынести в абстрактные методы все детали. Тесты должны быть просто и понятно написаны, а повторяющиеся куски кода выделены в отдельные функции. В Page Object мы отделяем логику действий, например, авторизовать пользователя, от конкретной реализации (найти поле почты, ввести туда данные, найти поле пароля, ввести туда данные, найти кнопку и т.д.). 

Рассмотрим такой простой тест-кейс:

Открыть главную страницу
Перейти на страницу логина
Ожидаемый результат:

Открыта страница логина

 

Давайте посмотрим на кусочек кода теста из предыдущего модуля, который реализует первую часть этого теста:

test_main_page.py:

link = "http://selenium1py.pythonanywhere.com/"


def test_guest_can_go_to_login_page(browser):
    browser.get(link)
    login_link = browser.find_element_by_css_selector("#login_link")
    login_link.click()
Что здесь происходит?

Мы открываем ссылку, находим элемент с определенным селектором и нажимаем на этот элемент.

Что мы на самом деле имеем в виду?

Мы хотим открыть страницу логина. Давайте выделим это действие в отдельную функцию с понятным названием, пока все в том же файле test_main_page.py :

def go_to_login_page(browser):
    login_link = browser.find_element_by_css_selector("#login_link")
    login_link.click()
и наш тест упрощается:

def test_guest_can_go_to_login_page(browser): 
   browser.get(link) 
   go_to_login_page(browser) 
При написании следующих тестов, когда нам понадобится перейти к странице логина с главной страницы, нам не нужно будет копировать этот кусочек кода или писать заново — мы сможем переиспользовать уже написанный метод.

Круто? А мы еще даже не написали Page Object. Дальше будет круче.

Дополнительно про Page Object вы можете почитать здесь:

https://github.com/SeleniumHQ/selenium/wiki/PageObjects

https://martinfowler.com/bliki/PageObject.html

https://medium.com/tech-tajawal/page-object-model-pom-design-pattern-f9588630800b
===================================================================================
Почему именно Page Object?
Можно, конечно, хранить всю логику наших тестов в одном файле под каким-нибудь условным названием steps.py, и для начала это уже неплохо. Но если мы тестируем большой веб-продукт с множеством разных состояний и переходов, этот файл может разрастись до огромных размеров, и найти в нем нужный метод будет непросто. Еще бывают ситуации, когда на разных страницах логически один и тот же метод имеет разную реализацию. Например, у нашего интернет-магазина может быть метод "добавить в корзину". Но пользователь может добавлять товар в корзину как со страницы каталога, так и со страницы самого товара. 

Было бы удобно выделить все методы, которые логически относятся к одной веб-странице в нашем продукте, в отдельный класс в нашем коде. Отсюда и название Page Object — это абстрактный объект, который содержит в себе методы для работы с конкретной веб-страницей. 

Важно! Обычно методы у Page Object бывают двух типов: сделать что-то и проверить что-то.

Рассмотрим страницу товара в интернет магазине http://selenium1py.pythonanywhere.com/catalogue/the-shellcoders-handbook_209/.

Какие могут быть методы у Page Object, ассоциированного с такой страницей? Запишем основные сценарии: 

добавить в корзину;
проверить, что есть сообщение об успешном добавлении в корзину;
перейти к написанию отзыва;
проверить, что есть название, цена, описание товара;
вернуться на главную.
Обратите внимание, что все проверки у нас тоже становятся отдельными методами. В самом тест-кейсе не остается никаких вспомогательных слов типа assert, только описание шагов. Прямо как в нашей тестовой документации.  

Тесты будут выглядеть примерно так:

def test_add_to_cart(browser):
    page = ProductPage(url="", browser)   # инициализируем объект Page Object
    page.open()                           # открываем страницу в браузере
    page.should_be_add_to_cart_button()   # проверяем что есть кнопка добавления в корзину
    page.add_product_to_cart()            # жмем кнопку добавить в корзину 
    page.should_be_success_message()      # проверяем что есть сообщение с нужным текстом
====================================================================================
Базовая страница для проекта: BasePage
Давайте перепишем тест из файла test_main_page.py с помощью паттерна Page Object, который мы добавили на этапе подготовки окружения. Мы будем работать с главной страницей нашего приложения, поэтому дадим классу говорящее название MainPage. 

Важно! В этом уроке мы напишем самостоятельно простую реализацию паттерна Page Object. А в следующих уроках уже рассмотрим существующие фреймворки и то, как они могут облегчить нам жизнь. Сейчас самая главная задача — осознать принципы работы. 

1. Создайте в своем проекте папку pages, там мы будем хранить все наши Page Object 

2. В папке создайте два файла: base_page.py и main_page.py  

Для начала сделаем базовую страницу, от которой будут унаследованы все остальные классы. В ней мы опишем вспомогательные методы для работы с драйвером.

3. В файле base_page.py создайте класс с названием BasePage. 

В Python такие вещи делаются с помощью следующей конструкции: 

class BasePage():
4. Теперь в наш класс нужно добавить методы. Первым делом добавим конструктор — метод, который вызывается, когда мы создаем объект. Конструктор объявляется ключевым словом __init__. В него в качестве параметров мы передаем экземпляр драйвера и url адрес. Внутри конструктора сохраняем эти данные как аттрибуты нашего класса. Получается примерно так: 

def __init__(self, browser, url):
    self.browser = browser
    self.url = url
5. Теперь добавим еще один метод open. Он должен открывать нужную страницу в браузере, используя метод get().

Объявите ниже в том же классе:

def open(self):
и реализуйте этот метод: нужна всего одна строка. Эту строку нужно отправить в качестве ответа на это задание, без отступов. 

6. После того как Stepik принял ваш ответ как правильный, добавьте новые файлы в Git и зафиксируйте изменения коммитом (не забудьте осмысленное сообщение).

 

В итоге у вас должен следующий код в файле base_page.py: 

class BasePage():
    def __init__(self, browser, url):
        self.browser = browser
        self.url = url

    def open(self): 
        # ваша реализация
====================================================================
 Page Object для главной страницы сайта
Теперь реализуем Page Object, который будет связан с главной страницей интернет-магазина. 

1. Откройте файл main_page.py 

2. В нем нужно сделать импорт базового класса BasePage: 

from .base_page import BasePage
3. В нем создайте класс  MainPage. Его нужно сделать наследником класса BasePage. Класс-предок в Python указывается в скобках: 

class MainPage(BasePage): 
таким образом, класс MainPage будет иметь доступ ко всем атрибутам и методам своего класса-предка. 

4. Перенесите метод из предыдущего урока в класс MainPage:

def go_to_login_page(browser):
   login_link = browser.find_element_by_css_selector("#login_link")
   login_link.click() 
Чтобы все работало, надо слегка видоизменить его. В аргументы больше не надо передавать экземпляр браузера, мы его передаем и сохраняем на этапе создания Page Object. Вместо него нужно указать аргумент self , чтобы иметь доступ к атрибутам и методам класса: 

def go_to_login_page(self):

Так как браузер у нас хранится как аргумент класса BasePage, обращаться к нему нужно соответствующим образом с помощью self: 

self.browser.find_element_by_css_selector("#login_link")
Заодно заменим find на более универсальный: 

self.browser.find_element(By.CSS_SELECTOR, "#login_link")
Итого, файл main_page.py: 

from .base_page import BasePage
from selenium.webdriver.common.by import By

class MainPage(BasePage): 
    def go_to_login_page(self):
        login_link = self.browser.find_element(By.CSS_SELECTOR, "#login_link")
        login_link.click()
 ==================================================================
 Первый тест на основе Page Object
Ура, первый прототип страницы мы уже реализовали! Давайте теперь перепишем тест с помощью Page Object: 

1. Откройте файл с вашим тестом test_main_page.py

2. В самом верху файла нужно импортировать класс, описывающий главную страницу: 

from .pages.main_page import MainPage
3. Теперь преобразуем сам тест в test_main_page.py: 

from .pages.main_page import MainPage


def test_guest_can_go_to_login_page(browser):
    link = "http://selenium1py.pythonanywhere.com/"
    page = MainPage(browser, link)   # инициализируем Page Object, передаем в конструктор экземпляр драйвера и url адрес 
    page.open()                      # открываем страницу
    page.go_to_login_page()          # выполняем метод страницы — переходим на страницу логина
4. Убедитесь, что тест проходит, запустив его все той же командой: 

pytest -v --tb=line --language=en test_main_page.py
5. Добавьте изменения и сделайте коммит (с осмысленным сообщением!)

Теперь наш тест почти полностью написан в модном стиле Page Object! Почему почти — узнаете в следующих шагах.
=======================================================================
Тест прошёл только если из from .pages.main_page import MainPage в test_main_page.py убрать первую точку: from pages.main_page import MainPage
@Sergey_Kuritsyn, а операционная систему у вас винда? знак точки в юникс системах символизирует текущую директорию, и соответственно нотация .some_dir.some_file срабатывает в терминатле пайчарма, а вот под видной может не прожеваться.

Но это только предположение, не тестил его. Сам сижу под линуксом, здесь работает только через точки (указание текущей директории). Для решения на винде ребята в комментах предлагают указывать путь с указанием папки: main_dir.some_dir.some_file
Эту ошибку устранил также благодаря комментам. Добавил pages во втором импорте:

from pages.base_page import BasePage
У меня сработало 2 варианта решения проблемы с точкой перед pages в самой верхней строке.
1-й: убрать эту точку - код заработал

2-й: переименовать директорию с кодом (была: stepik-test-project, а стала: stepik_test_project). 

Python ругался на некорректные символы (дефисы) в названии директории и не хотел запускать код корректно. Стоило поправить и всё заработало. 

Может кому пригодится
=========================================================================
                  
Методы-проверки в Page Object
Давайте теперь автоматизируем другой тест-кейс и посмотрим на его примере, как делать методы-проверки. 

Допустим, нам нужно проверять такой сценарий: 

Открыть главную страницу 
Проверить, что есть ссылка, которая ведет на логин 
Для этого в классе MainPage нужно реализовать метод, который будет проверять наличие ссылки. Обычно все такие методы-проверки называются похожим образом, мы будем называть их should_be_(название элемента). 

Итак, в классе MainPage создайте метод should_be_login_link. 

Для первой пробы можно реализовать его самым примитивным образом: 

def should_be_login_link(self):
    self.browser.find_element(By.CSS_SELECTOR, "#login_link_invalid")
Сейчас мы намеренно сделали селектор неправильным, чтобы посмотреть, что именно выдаст тест, если поймает баг. Это хорошая практика: писать сначала красные тесты и только потом делать их зелеными.  

Добавляем в файл с тест-кейсами новый тест: 

def test_guest_should_see_login_link(browser):
    link = "http://selenium1py.pythonanywhere.com/"
    page = MainPage(browser, link)
    page.open()
    page.should_be_login_link()
Запустите получившийся тест: 

pytest -v --tb=line --language=en test_main_page.py
Вывод об ошибке не очень понятный, правда? Разобраться, что именно пошло не так, довольно тяжело. Поэтому в следующем шаге нам нужно будет обработать исключение, которое выбрасывает WebDriver. 

В качестве ответа на данное задание напишите название исключения, которое вы получили в результате запуска теста. 

Познакомиться подробнее с работой с исключениями в Python вы можете в данной статье: http://pythonworld.ru/tipy-dannyx-v-python/isklyucheniya-v-python-konstrukciya-try-except-dlya-obrabotki-isklyuchenij.html                   
                  
NoSuchElementException 
============================================================================
Проверка элемента на странице
Чтобы выводить адекватное сообщение об ошибке, мы будем все проверки осуществлять с помощью assert и перехватывать исключения.

Для этого напишем вспомогательный метод поиска элемента в нашей базовой странице BasePage, который будет возвращать нам True или False. Можно сделать это по-разному (с настройкой явных или неявных ожиданий). Сейчас воспользуемся неявным ожиданием.

1. В конструктор BasePage добавим команду для неявного ожидания со значением по умолчанию в 10:

def __init__(self, browser, url, timeout=10):
    self.browser = browser
    self.url = url
    self.browser.implicitly_wait(timeout)
2. Теперь в этом же классе реализуем метод is_element_present, в котором будем перехватывать исключение. В него будем передавать два аргумента: как искать (css, id, xpath и тд) и собственно что искать (строку-селектор). 

Чтобы перехватывать исключение, нужна конструкция try/except: 

def is_element_present(self, how, what):
    try:
        self.browser.find_element(how, what)
    except (имя исключения):
        return False
    return True
Чтобы импортировать нужное нам исключение, в самом верху файла нужно указать: 

from selenium.common.exceptions import имя_исключения
Отлично! Теперь для всех проверок, что элемент действительно присутствует на странице, мы можем использовать этот метод. 

3. Теперь модифицируем метод проверки ссылки на логин так, чтобы он выдавал адекватное сообщение об ошибке: 

def should_be_login_link(self):
    assert self.is_element_present(By.CSS_SELECTOR, "#login_link_invalid"), "Login link is not presented"
Запустите тесты и посмотрите, что вывод об ошибке стал более понятным: 

pytest -v --tb=line --language=en test_main_page.py
И не забудьте заменить селектор на правильный, чтобы тест снова проходил! 

4. Сделайте коммит изменений (с осмысленным сообщением).
===========================================================================
Элементы страниц в паттерне Page Object
Помните, мы говорили о том, что тесты почти соответствуют подходу Page Object? 

Сейчас разберемся, почему почти на примере короткой и поучительной истории.

У нас уже есть два тест-кейса, которые так или иначе взаимодействуют со ссылкой на логин. Представим себе ситуацию, что у нас модный быстрый agile: разработчики постоянно вносят изменения в продукт. В какой-то прекрасный момент изменения коснулись и шапки сайта. Вот приходит к вам разработчик с новой ссылкой и говорит протестировать.

Замените линк, на котором запускаются тесты на http://selenium1py.pythonanywhere.com/catalogue/the-shellcoders-handbook_209?promo=midsummer 

Запустите тесты командой:

pytest -v --tb=line --language=en test_main_page.py
Тесты упали, и теперь нам нужно их поддерживать, то есть чинить. Подберите новый селектор к ссылке на логин. 

Нам придется поправить в файле main_page.py несколько мест, где используется измененный селектор. Посчитайте, сколько строк вам нужно будет отредактировать, чтобы починить ваши тесты, и внесите полученное число в первое поле ответа ниже. 

Чтобы этого избежать, при проектировании тестов (да и вообще кода) хорошей практикой является выносить селектор во внешнюю переменную. 

Давайте этим и займемся: 

1. В папке pages создайте новый файл locators.py 

2. Внутри создайте новый класс. Каждый класс будет соответствовать каждому классу PageObject: 

from selenium.webdriver.common.by import By


class MainPageLocators():
    LOGIN_LINK = (By.CSS_SELECTOR, "#login_link")
теперь каждый селектор — это пара: как искать и что искать. 

3. В файле main_page.py импортируйте новый класс с локаторами 

from .locators import MainPageLocators
4. Теперь в классе MainPage замените все строки, где содержится "#login_link" таким образом:

def should_be_login_link(self):
    assert self.is_element_present(*MainPageLocators.LOGIN_LINK), "Login link is not presented"
Обратите внимание здесь на символ *, он указывает на то, что мы передали именно пару, и этот кортеж нужно распаковать. 

5. Запустите тесты с помощью той же самой команды: 

pytest -v --tb=line --language=en test_main_page.py
Они, конечно, снова упадут. Но теперь посчитайте, сколько строк вам нужно будет отредактировать, когда тесты написаны в такой конфигурации? Внесите число во второе поле ответа. 

 

Итак, PageObject — это не только методы, но и элементы.  

Исправлять руками сломанные селекторы во всем проекте — долго и муторно, и есть большой риск забыть и оставить старый селектор. Когда мы выносим селекторы в отдельную сущность, мы уменьшаем время на поддержку тестов и сильно упрощаем себе жизнь в долгосрочной перспективе. 

А ещё спринт спустя промоакция закончилась, и фичу с изменением шапки откатили назад. Теперь ссылка работает так же, как раньше. Удалите ссылку с промоакцией, и верните обычную ссылку для запуска тестов: 

link = "http://selenium1py.pythonanywhere.com/"
Не забудьте вернуть старый селектор #login_link, так чтобы тесты снова проходили. Они нам еще пригодятся! 
============================================================================
Реализация LoginPage
Если вы хорошо ориентируетесь в тест-дизайне, скорее всего вас немного коробит тест с переходом к логину — там ведь нет никаких проверок. Давайте проверим, что мы действительно перешли на страницу логина. Для этого нам будет нужен новый Page Object. Заодно разберемся, как между ними переключаться в ходе теста. 

Скачайте файл с шаблоном для LoginPage. Добавьте его в папку pages. Внутри есть заглушки для методов проверок: 

should_be_login_url
should_be_login_form
should_be_register_form
Реализуйте их самостоятельно: 

1. В файле locators.py создайте класс LoginPageLocators 

2. Подберите селекторы к формам регистрации и логина, добавьте их в класс LoginPageLocators

3. Напишите проверки, используя эти селекторы. Не забудьте через запятую указать адекватное сообщение об ошибке. Напишите сначала красный тест, чтобы убедиться в понятности вывода. 

4. В методе should_be_login_url реализуйте проверку, что подстрока "login" есть в текущем url браузера. Для этого используйте соответствующее свойство Webdriver.
https://selenium-python.readthedocs.io/api.html#selenium.webdriver.remote.webdriver.WebDriver.current_url
5. Добавьте изменения в коммит с осмысленным сообщением

Теперь посмотрим, как можно осуществлять переход между страницами. 
==============================================================================
 Переходы между страницами
Переход можно реализовать двумя разными способами. 

Первый способ: возвращать нужный Page Object.

Для этого в файле main_page.py нужно сделать импорт страницы с логином: 

from .login_page import LoginPage
Затем в методе, который осуществляет переход к странице логина, проинициализировать новый объект Page и вернуть его: 

def go_to_login_page(self):
    link = self.browser.find_element(*MainPageLocators.LOGIN_LINK)
    link.click()
    return LoginPage(browser=self.browser, url=self.browser.current_url) 
Обратите внимание! При создании объекта мы обязательно передаем ему тот же самый объект драйвера для работы с браузером, а в качестве url передаем текущий адрес.

Теперь в тесте нам не нужно думать про инициализацию страницы: она уже создана. Сохранив возвращаемое значение в переменную, мы можем использовать методы новой страницы в тесте:

def test_guest_can_go_to_login_page(browser):
    link = "http://selenium1py.pythonanywhere.com"
    page = MainPage(browser, link)
    page.open()
    login_page = page.go_to_login_page()
    login_page.should_be_login_page()
Плюсы такого подхода: 

тест выглядит аккуратнее — не нужно инициализировать страницу в теле теста;
явно возвращаем страницу — тип страницы ассоциирован с методом;
не нужно каждый раз думать в разных тестах про инициализацию страницы — уменьшаем дублирование кода;
минусы: 

если у нас копится большое количество страниц и переходов — образуется много перекрестных импортов;
большая связность кода — при изменении логики придется менять возвращаемое значение;
сложнее понимать код, так как страница инициализируется неявно;
образуются циклические зависимости, что часто приводит к ошибкам.
Второй подход: переход происходит неявно, страницу инициализируем в теле теста: 

1. Закомментируйте строку с возвращаемым значением 

def go_to_login_page(self):
    link = self.browser.find_element(*MainPageLocators.LOGIN_LINK)
    link.click()
    # return LoginPage(browser=self.browser, url=self.browser.current_url) 
2. Инициализируем LoginPage в теле теста (не забудьте импортировать в файл нужный класс): 

from .pages.login_page import LoginPage

def test_guest_can_go_to_login_page(browser):
    link = "http://selenium1py.pythonanywhere.com"
    page = MainPage(browser, link)
    page.open()
    page.go_to_login_page()
    login_page = LoginPage(browser, browser.current_url)
    login_page.should_be_login_page()
Плюсы:

меньше связность кода;
меньше импортов, нет перекрестных импортов;
больше гибкость;
в тесте понятнее что происходит, т.к. явно инициализируем страницу.
Минусы:

появляется лишний шаг в тест-кейсе;
каждый раз при написании теста нужно думать про корректные переходы;
дублируется код.
И тот и другой подход можно успешно применять в своих проектах, главное делать это с умом. Сейчас оставьте второй вариант с явной инициализацией страниц в теле теста, чтобы избежать лишних сложностей с циклическими зависимостями. 

Уберите лишний закомментированный код, и зафиксируйте изменения в коммите с осмысленным сообщением.
========================================================
Удобство поддержки тестов — инкапсуляция бизнес-логики в методах
Что делать, если изменилась логика взаимодействия со страницей, которая используется у нас в нескольких тестах? Например, нам нужно проверить возможность перехода на страницу логина по ссылке в навбаре для каждой из страниц сайта. Предположим, что таких страниц 20, и, значит, у нас есть 20 тестов, использующих метод go_to_login_page класса MainPage. Затем разработчики добавили alert, который вызывается при клике на нужную нам ссылку. Мы увидим, что все 20 тестов упали, так как в методе go_to_login_page нет шага с обработкой alert, следовательно, метод should_be_login_page не сработает. Добавив обработку alert в метод go_to_login_page, мы восстановим работоспособность всех тестов, не меняя самих тестов:

def go_to_login_page(self):
   link = self.browser.find_element_by_css_selector("#login_link")
   link.click()
   alert = self.browser.switch_to.alert
   alert.accept()
Это еще одно преимущество использования паттерна Page Object — мы разделяем сам тест и логику взаимодействия со страницей. Тест становится более читабельным, и его легче поддерживать при изменениях в коде приложения.
==============================================================
Page Object содержит в себе методы для работы с веб-страницей
Page Object - это паттерн для организации кода авто-тестов
==============================================================

Page Object уменьшает временные затраты на поддержку автотестов
Паттерн Page Object позволяет хранить селекторы в одном месте, отдельно от логики, что упрощает поддержку автотестов
================================================================
Задание: добавление в корзину со страницы товара
Давайте, прежде чем двигаться дальше, закрепим знания на практике. 

Представьте, что вы работаете тестировщиком-автоматизатором в IT-отделе интернет-магазина. QA Lead поручил вам задание автоматизировать следующий тестовый сценарий: 

Открываем страницу товара (http://selenium1py.pythonanywhere.com/catalogue/the-shellcoders-handbook_209/?promo=newYear). Обратите внимание, что в ссылке есть параметр "?promo=newYear". Не теряйте его в авто-тесте, чтобы получить проверочный код.
Нажимаем на кнопку "Добавить в корзину".
*Посчитать результат математического выражения и ввести ответ. Используйте для этого метод solve_quiz_and_get_code(), который приведен ниже. Например, можете добавить его в класс BasePage, чтобы использовать его на любой странице. Этот метод нужен только для проверки того, что вы написали тест на Selenium. После этого вы получите код, который нужно ввести в качестве ответа на данное задание. Код будет выведен в консоли интерпретатора, в котором вы запускаете тест. Не забудьте в конце теста добавить проверки на ожидаемый результат.
Ожидаемый результат: 

Сообщение о том, что товар добавлен в корзину. Название товара в сообщении должно совпадать с тем товаром, который вы действительно добавили.
Сообщение со стоимостью корзины. Стоимость корзины совпадает с ценой товара. 
Тест нужно написать, используя паттерн Page Object. Для этого вам нужно: 

Добавить новый файл для тест-кейсов, связанных со страницей товара. Назовите файл с тестами test_product_page.py.
Создать класс Page Object для страницы товара. Опишите его в файле product_page.py в папке pages.
Описать в нем метод для добавления в корзину.
Дописать методы-проверки.
Описать необходимые локаторы к элементам страницы.
Написать сам тест-кейс, используя все вышеописанное. Назовите тест test_guest_can_add_product_to_basket.
Можете начинать работу с любого пункта, но хорошей практикой считается написать сначала шаги и структуру теста, а потом описывать конкретную реализацию. 

*Используйте этот метод в тесте для получения проверочного кода: 

from selenium.common.exceptions import NoAlertPresentException # в начале файла

def solve_quiz_and_get_code(self):
    alert = self.browser.switch_to.alert
    x = alert.text.split(" ")[2]
    answer = str(math.log(abs((12 * math.sin(float(x))))))
    alert.send_keys(answer)
    alert.accept()
    try:
        alert = self.browser.switch_to.alert
        alert_text = alert.text
        print(f"Your code: {alert_text}")
        alert.accept()
    except NoAlertPresentException:
        print("No second alert presented")
Чтобы увидеть проверочный код в консоли, запускайте PyTest с параметром -s:

pytest -s test_foo.py
===============================================================================
Задание: независимость от данных
Хорошие автотесты должны быть максимально независимы от данных. Худшее, что можно сделать в тесте это "захардкодить" проверки для объектов, которые существуют только на вашем конкретном инстансе. Почему? Потому что данные будут постоянно меняться, и при каждом таком изменении придется чинить автотесты. Еще это ухудшает переиспользование метода: допустим, мы хотим прогнать тест для множества товаров, тогда придется писать большое количество проверок: по одной для каждого товара. В конечном итоге, это сказывается на качестве продукта, так как такие тесты работают на узкой выборке страниц.

Общая рекомендация: ваши тесты не должны зависеть от того, что вы не можете контролировать. Это может быть информация, уже хранящаяся в базе данных, или сторонние сервисы, которые использует ваше приложение. Вы можете проверять конкретные данные только в случае, когда используете специально подготовленную тестовую базу, инициируемую перед каждым запуском тестов, или добавляете нужные данные в базу данных напрямую или через API приложения. 

Попробуйте запустить автотест, который мы написали на предыдущем шаге, на странице http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=newYear2019.

Если в предыдущем тесте после добавления товара в корзину вы проверяли в сообщении сайта фиксированную строку "The shellcoder's handbook", то тест упадет, так как теперь мы добавили другой товар. Если тест прошел, то вы молодец и можете просто вставить новый проверочный код в этом задании. 

Чтобы тест был независимым от контента: 

Измените методы проверки таким образом, чтобы они принимали как аргумент название товара и цену товара.
Сделайте метод, который вытаскивает из элемента текст-название товара и возвращает его.
Сделайте такой же метод для цены.
Теперь проверяйте, что название товара в сообщении совпадает с заголовком товара.
================================================================================
Задание: независимость контента, ищем баг
Эта задача для настоящих ниндзя автотестинга. Не потому что она сложная, а потому что сейчас мы будем ловить с вами настоящий баг с помощью наших автотестов. Для нашего интернет-магазина было запущено несколько новых промо-акций, одна из которых привела к появлению бага. Промо-акция включается путем добавления параметра ?promo=offerN к ссылке на товар.

К счастью, нам не придется менять наш тест, чтобы проверить изменения в коде. Мы просто запустим всё тот же тест на странице http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/ с параметризацией. Вам нужно определить, при каком значении параметра promo автотест упадет. Для этого проверьте результат работы PyTest и найдите url, на котором произошла ошибка. Значение параметра может изменяться от offer0 до offer9.

Пример ссылки: http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer0. Если баг будет найден на этой странице, то введите в качестве ответа http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer0.

Запустить сразу несколько тестов вы можете, используя @pytest.mark.parametrize. Мы уже сделали для вас шаблон теста:

@pytest.mark.parametrize('link', ["http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer0",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer1",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer2",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer3",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer4",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer5",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer6",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer7",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer8",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer9"])
def test_guest_can_add_product_to_basket(browser, link):
    # ваша реализация теста
Подсказка: баг должен быть найден методом проверки.

После того как вы обнаружили баг, учитывая что чинить его не собираются, лучше всего пометить падающий тест как xfail или skip. Помните, как мы такое проворачивали в третьем модуле? Освежить память: XFail: помечать тест как ожидаемо падающий.
https://stepik.org/lesson/236918/step/5?unit=209305
С параметризацией делается это примерно так:  

@pytest.mark.parametrize('link', ["okay_link",
                                  pytest.param("bugged_link", marks=pytest.mark.xfail),
                                  "okay_link"])
Подробнее: Skip/xfail with parametrize
https://pytest.org/en/stable/skipping.html#skip-xfail-with-parametrize
После всех манипуляций не забудьте зафиксировать изменения коммитом.
=========================================
 Отрицательные проверки: как проверить отсутствие элемента
Иногда в ходе написания авто-тестов возникает ситуация, когда нам нужно проверить не только присутствие элемента на странице, но и то, что элемента на странице нет. Здесь стоит разделять две принципиально разные ситуации, в зависимости от того как ведет себя веб-приложение: 

 1. Элемент потенциально может появится на странице (но вообще-то не должен). Например, мы открываем страницу товара, и ожидаем, что там нет сообщения об успешном добавлении в корзину. Мы проверяем, что элемента нет, но при позитивном сценарии, когда мы добавляем товар в корзину, сообщение тоже появляется не сразу. Если при негативной проверке мы не добавим ожидание, а сразу выдадим результат: "True, элемента действительно нет, все хорошо", мы рискуем нарваться на ложно-зеленый тест. То есть, можем пропустить баг. 

2. Элемент присутствует на странице и должен исчезнуть со временем или в результате действий пользователя. Это может быть, например, удаление товара из корзины, или исчезновение лоадера с загрузкой. 

Почему нужно писать такие проверки с осторожностью? 
Во-первых, нам приходится всегда гарантированно ждать. В первом примере нам всегда нужно ждать несколько секунд, чтобы убедиться, что элемент не появился. Если мы используем нашу написанную функцию is_element_present, то тест с такой проверкой будет ждать полные и честные 10 секунд:

def should_not_be_success_message(self):
    assert not self.is_element_present(*ProductPageLocators.SUCCESS_MESSAGE),\
        "Success message is presented"
Что очень много для зелёного теста. То есть implicit_wait уже в такой ситуации не подходит, придется использовать явное ожидание и аккуратно подбирать условия. Время ожидания тоже придется подбирать эмпирически, путем проб, ошибок, ложноположительных и ложноотрицательных результатов. 

Во-вторых, еще одна загвоздка с отрицательными проверками в том, что они могут давать ложноположительные срабатывания, если селектор устарел. Проверяем, что элемента с таким селектором нет, — проверка проходит, так как у элемента уже другой селектор. Элемент есть на экране — это баг, а тест зеленый. Это плохо! 

Поэтому на каждый негативный тест обязательно должен приходиться положительный тест. В одном тесте проверяем, что элемента нет, в соседнем тесте, что элемент есть. Тогда мы сможем отслеживать актуальность селектора и не пропустим такой баг. 

Дополнительная ссылка на пост Виталия Котова про распространенные грабли и отрицательные проверки, в том числе:

 UI-автотесты: как делать не стоит
https://habr.com/ru/company/badoo/blog/419419/
Как же тогда реализовывать такие проверки? 
Нужно ориентироваться на конкретную ситуацию, но общий совет — использовать явные ожидания и Expected Conditions, о которых мы говорили в предыдущих модулях. 

Можно добавить в BasePage абстрактный метод, который проверяет, что элемент не появляется на странице в течение заданного времени: 

def is_not_element_present(self, how, what, timeout=4):
    try:
        WebDriverWait(self.browser, timeout).until(EC.presence_of_element_located((how, what)))
    except TimeoutException:
        return True

    return False
Тогда его использование Page Object для страницы товара будет выглядеть так: 

def should_not_be_success_message(self):
    assert self.is_not_element_present(*ProductPageLocators.SUCCESS_MESSAGE), \
       "Success message is presented, but should not be"
Если же мы хотим проверить, что какой-то элемент исчезает, то следует воспользоваться явным ожиданием вместе с функцией until_not, в зависимости от того, какой результат мы ожидаем: 

def is_disappeared(self, how, what, timeout=4):
    try:
        WebDriverWait(self.browser, timeout, 1, TimeoutException).\
            until_not(EC.presence_of_element_located((how, what)))
    except TimeoutException:
        return False

    return True
Метод-проверка в классе про страницу товара будет выглядеть аналогично should_not_be_success_message, напишите его самостоятельно.

 

Обратите внимание на разницу между методами is_not_element_present и is_disappeared. 

is_not_element_present: упадет, как только увидит искомый элемент. Не появился: успех, тест зеленый. 

is_disappeared: будет ждать до тех пор, пока элемент не исчезнет. 

 

Резюмируя, можно сказать, что разрабатывать такие проверки нужно очень аккуратно, использовать явные ожидания для сокращения времени прогона теста и всегда добавлять позитивную проверку на элемент в другом тесте. Без явной необходимости таких проверок лучше избегать. 

==========================================================================
  Плюсы наследования: магия ООП
Если вы использовали ранее парадигму ООП при написании кода, то уже представляете, как хорошая архитектура может облегчить жизнь. В этом плане код автотестов ничем не отличается от кода приложений — мы можем использовать всё те же приёмы для организации методов.

Здесь мы рассмотрим лишь один из примеров: использование механизма наследования.

Мы уже немного использовали механизм наследования, когда сделали базовый класс для всех наших проверок BasePage, а от него наследовали все остальные Page Object: LoginPage, MainPage. Сейчас у нас в классе BasePage в основном технические детали — реализация поиска элементов, метод для открытия страницы и прохождения капчи. Но никто не мешает нам добавить туда элементы и методы, которые являются общими для всех страниц.



 
ВАЖНО! Не нужно запихивать в базовый класс все, что плохо лежит и может когда-нибудь пригодиться. Добавлять нужно только то, что ОБЯЗАТЕЛЬНО будет на каждой странице-наследнике, иначе есть риск, что увеличение строк кода в файле будет неконтролируемым, и поддерживать его будет сложно.

Вообще говоря, мы можем строить какую угодно иерархию наших классов для взаимодействия с веб-приложением, если это поможет избежать дублирования кода. Например, есть набор страниц с общими методами, мы можем организовать их в виде наследования с дополнительным "слоем".

Например, когда мы тестируем страницу урока в Stepik (это та страница, на которой вы сейчас находитесь), мы используем LessonPage как базовый класс, где содержатся общие элементы и методы для всех типов шагов (шапка, комментарии, боковое расписание) и класс-наследник для каждого типа заданий, а их на Stepik более 20, каждый со своими уникальными методами и элементами. Такой подход позволяет избежать дублирования кода, и необходимости поддерживать файл на >1000 строк кода. 

============================================================================
Плюсы наследования: пример
В предыдущем уроке, мы написали тест "гость может перейти на страницу логина с главной страницы магазина". Но если вы внимательно посмотрите на остальные страницы, то заметите, что ссылка на страницу логина присутствует на каждой странице. Если мы хотим добавить тест "гость может перейти на страницу логина со страницы товара", то для избежания дублирования, логично перенести соответствующие методы в класс BasePage. Давайте так и поступим: 

В файле locators.py создаем новый класс BasePageLocators и переносим туда соответствующие элементы:

class BasePageLocators():
    LOGIN_LINK = (By.CSS_SELECTOR, "#login_link")
    LOGIN_LINK_INVALID = (By.CSS_SELECTOR, "#login_link_inc")
В файл base_page.py переносим соответствующие методы, заменяя класс с локаторами на BasePageLocators:  

from .locators import BasePageLocators


class BasePage():
...
    def go_to_login_page(self):
        link = self.browser.find_element(*BasePageLocators.LOGIN_LINK_INVALID)
        link.click()

    def should_be_login_link(self):
        assert self.is_element_present(*BasePageLocators.LOGIN_LINK), "Login link is not presented"
... 
Примечание: методы лучше всего описывать в классе в алфавитном порядке, так проще ориентироваться и находить.

В классе MainPage у нас не осталось никаких методов, поэтому добавим туда заглушку: 

class MainPage(BasePage):
    def __init__(self, *args, **kwargs):
        super(MainPage, self).__init__(*args, **kwargs)
Как вы уже знаете, метод __init__ вызывается при создании объекта. Конструктор выше с ключевым словом super на самом деле только вызывает конструктор класса предка и передает ему все те аргументы, которые мы передали в конструктор MainPage. 

Теперь мы можем легко добавлять тесты вида "гость может перейти на страницу логина со страницы Х". 

Добавляем в файл c тестами test_product_page.py новые тесты: 

def test_guest_should_see_login_link_on_product_page(browser):
    link = "http://selenium1py.pythonanywhere.com/en-gb/catalogue/the-city-and-the-stars_95/"
    page = ProductPage(browser, link)
    page.open()
    page.should_be_login_link()
Добавьте самостоятельно второй тест 

test_guest_can_go_to_login_page_from_product_page 
Запустите тесты и убедитесь, что они проходят. 

Зафиксируйте изменения коммитом. 
============================================================================
Группировка тестов: setup 
А сейчас воспользуемся магией ООП уже для организации кода самих тест-кейсов. PyTest позволяет объединять несколько тест-кейсов в один класс. Зачем это делать и почему удобно? 

Во-первых, мы можем логически сгруппировать тесты в один класс просто ради более стройного кода: удобно, когда тесты, связанные с одним компонентом лежат в одном классе, а с помощью pytest.mark можно помечать сразу весь класс. Основное правило такое: название класса должно начинаться с Test, чтобы PyTest смог его обнаружить и запустить.

Давайте например объединим в группу два теста в файле test_main_page.py и пометим его меткой login_guest:

@pytest.mark.login_guest
class TestLoginFromMainPage():
    # не забываем передать первым аргументом self                       
    def test_guest_can_go_to_login_page(self, browser):     
         # реализация теста

    def test_guest_should_see_login_link(self, browser):
         # реализация теста
Попробуйте запустить тесты в этом файле с меткой (нужно добавить "-m login_guest"). Вы увидите, что запустились оба теста, хотя метка всего одна. 

Во-вторых, для разных тест-кейсов можно выделять общие функции, чтобы не повторять код. Эти функции называются setup — функция, которая выполнится перед запуском каждого теста из класса, обычно туда входит подготовка данных, и teardown — функция, которая выполняется ПОСЛЕ каждого теста из класса, обычно там происходит удаление тех данных, которые мы создали во время теста. Хороший автотест должен сработать даже на чистой базе данных и удалить за собой сгенерированные в тесте данные. Такие функции реализуются с помощью фикстур, которые мы изучили в предыдущем модуле. Чтобы функция запускалась автоматически перед каждым тест-кейсом, нужно пометить её как @pytest.fixture с параметрами scope="function", что значит запускать на каждую функцию, и autouse=True, что значит запускать автоматически без явного вызова фикстуры.

Мы уже немного говорили про независимость от контента в предыдущих шагах — идеальным решением было бы везде, где мы работаем со страницей продукта, создавать новый товар в нашем интернет-магазине перед тестом и удалять по завершении теста. К сожалению, наш интернет-магазин пока не имеет возможности создавать объекты по API, но в идеальном мире мы бы написали вот такой тест-класс в файле test_product_page.py:

@pytest.mark.login
class TestLoginFromProductPage():
    @pytest.fixture(scope="function", autouse=True)
    def setup(self):
        self.product = ProductFactory(title = "Best book created by robot")
        # создаем по апи
        self.link = self.product.link
        yield
        # после этого ключевого слова начинается teardown
        # выполнится после каждого теста в классе
        # удаляем те данные, которые мы создали 
        self.product.delete()
        

    def test_guest_can_go_to_login_page_from_product_page(self, browser):
        page = ProductPage(browser, self.link)
        # дальше обычная реализация теста

    def test_guest_should_see_login_link(self, browser):
        page = ProductPage(browser, self.link)
        # дальше обычная реализация теста
Работа с API выходит за рамки этого курса, но знание о том, что можно группировать тесты и выделять подготовительные шаги в единые для всех тестов функции — важно для каждого автоматизатора.
=============================================================================
Задание: setup
Ниже вы найдете небольшой пазл из строк кода, которые нужно собрать в правильном порядке. 

Мы хотим обернуть тест-кейс test_guest_cant_see_success_message в тестовый класс TestAddToBasketFromProductPage с подготовкой данных, точно так же как в примере из предыдущего шага. 

Расположите элементы списка в правильном порядке
Верно решили 2 158 учащихся
Из всех попыток 40% верных
 Отлично!
@pytest.mark.add_to_basket
class TestAddToBasketFromProductPage(object):
    @pytest.fixture(scope="function", autouse=True)
    def setup(self):
        self.product = ProductFactory(title="Best book created by robot")
        self.link = self.product.link
        yield
        self.product.delete()
    def test_guest_cant_see_success_message(self, browser):
        page = ProductPage(browser, self.link)
===============================================================================
Задание: группировка тестов и setup
ВАЖНО! Вообще говоря манипулировать браузером в сетапе и уж тем более что-то там проверять — это плохая практика, лучше так не делать без особой необходимости. Здесь этот пример исключительно в учебных целях, чтобы вы попробовали писать сетапы для тестов. В реальной жизни мы реализовали бы все эти манипуляции с помощью API или напрямую через базу данных.

В этом задании мы хотим добавить тестовые сценарии не только для гостей сайта, но и для зарегистрированных пользователей. Для этого:

В файле test_product_page.py добавьте новый класс для тестов TestUserAddToBasketFromProductPage.
Добавьте туда уже написанные тесты test_guest_cant_see_success_message и test_guest_can_add_product_to_basket и переименуйте, заменив guest на user. Шаги тестов не изменятся, добавится лишь регистрация перед тестами. Параметризация здесь уже не нужна, не добавляйте её. 
Добавьте в LoginPage метод register_new_user(email, password), который принимает две строки и регистрирует пользователя. Реализуйте его, описав соответствующие элементы страницы.
Добавьте в BasePage проверку того, что пользователь залогинен:
def should_be_authorized_user(self):
    assert self.is_element_present(*BasePageLocators.USER_ICON), "User icon is not presented," \
                                                                 " probably unauthorised user"
Селектор соответственно в BasePageLocators:
USER_ICON = (By.CSS_SELECTOR, ".icon-user")
Добавьте в класс фикстуру setup. В этой функции нужно:
открыть страницу регистрации;
зарегистрировать нового пользователя;
проверить, что пользователь залогинен.
Запустите оба теста и убедитесь, что они проходят и действительно регистрируют новых пользователей
Зафиксируйте изменения в репозитории коммитом с осмысленным сообщением 
Примечание: 

yield писать не нужно — пользователей удалять мы не умеем. Генерировать email адреса для пользователей можно по-разному, один из вариантов, чтобы избежать повторения, использовать текущее время с помощью модуля time:

import time # в начале файла

email = str(time.time()) + "@fakemail.org"
=========================================================================
Финишная прямая: готовим код к ревью
Поздравляем, вы уже почти закончили свой финальный проект! В следующем шаге вы отправите его на оценку сокурсникам, а сейчас время немного причесать его и довести до совершенства. Следуйте этим советам, чтобы получить максимальные  баллы:

1. Убедитесь, что в репозитории есть все нужные файлы. Все файлы, где хранятся страницы, лежат в отдельной папке pages. В итоге структура файлов и папок должна выглядеть так:



Убедитесь, что ничего не потерялось. Обратите внимание обязательно на conftest.py. 

2. Проверьте requirements.txt и убедитесь что там указаны нужные версии пакетов, как минимум: 

pytest==5.1.1
selenium==3.14.0
Желательно, чтобы там еще не было лишнего. Помните, что задание будут проверять ваши сокурсники, и им вряд ли понравится ставить огромную кучу пакетов. 

3. Проверьте, что все тесты, описанные в test_main_page.py и test_product_page.py запускаются и проходят (очевидно, за исключением тех, которые помечены как xfail/skip). 

4. Проверьте стиль кода. Представьте, что ваш код будет читать человек, который никогда не программировал и не автоматизировал тестирование — ему должно быть понятно, что происходит. 

Убедитесь что все переменные, методы и классы, которые вы создаете, называются осмысленно. 

Удалите весь ненужный закомментированный код, помним, что захламлять репозиторий лишним — плохой тон. 

5. Откройте test_product_page.py. Убедитесь, что там есть следующие тесты: 

test_user_can_add_product_to_basket

test_guest_can_add_product_to_basket

test_guest_cant_see_product_in_basket_opened_from_product_page

test_guest_can_go_to_login_page_from_product_page

Отмаркируйте эти тесты меткой:

@pytest.mark.need_review

Не забудьте зарегистрировать метку, чтобы избежать предупреждений: Как же регистрировать метки?
https://stepik.org/lesson/236918/step/2?unit=209305
Убедитесь, что при запуске с помощью следующей команды тесты запускаются и успешно проходят: 

pytest -v --tb=line --language=en -m need_review
6. Убедитесь, что все тесты написаны в стиле PageObject: нет assert в теле тестов, все методы действия и проверки выделены в отдельные методы в классах PageObject, все селекторы лежат в locators.py.

7. Зафиксируйте все изменения коммитом. Не добавляйте локальные файлы окружения, файлы ide и прочие вспомогательные вещи в отслеживаемые. Нужен только код!

8. Сделайте пуш изменений в свой репозиторий.

9. Откройте репозиторий на GitHub и перепроверьте пункты 1, 2, 4, 5 и 6.

10. Порадуйтесь за себя и переходите к следующему шагу.

 ============================================================
                     